<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:NOTE-git</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="git-">Git - 版本控制工具</h1>
<p><img src="./img/git-logo.png" alt="git logo"></p>
<h2 id="-">版本控制系统</h2>
<blockquote>
<p>版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
</blockquote>
<h3 id="-">开发场景和问题再现</h3>
<ul>
<li>问题1：改变代码，意识到这是一个错误，想要恢复？</li>
<li>问题2：要维护产品的多个版本？</li>
<li>问题3：想看看做了多少工作，在哪里，何时和由谁？</li>
<li>问题4：两个开发人员同时要改变同一个文件，改写彼此的工作？</li>
<li>问题5：多人开发如何同步代码？</li>
<li>问题6：想要看到两个(或更多)版本的代码之间的区别？</li>
</ul>
<h3 id="-">版本控制系统的作用</h3>
<ul>
<li>使用版本控制系统以上问题迎刃而解</li>
</ul>
<p>使用了版本控制系统，每一个团队成员都可以在任何时间对任何文件毫无顾虑的进行修改，版本控制系统可以把之后所有的改动合并成一个共同的版本，不论是一个文件还是整个项目。这个共同的中心平台就是我们的版本控制系统。</p>
<h3 id="-">三种版本控制系统</h3>
<ul>
<li>1 本地版本控制系统</li>
<li>2 集中式版本控制系统 </li>
<li>3 分布式版本控制系统 </li>
</ul>
<h3 id="-">本地版本控制系统</h3>
<p><img src="./img/local.png" alt="本地版本控制系统"></p>
<ul>
<li>复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别</li>
<li>缺点：手动维护困难、无法多人维护</li>
</ul>
<h3 id="-">集中式版本控制系统</h3>
<p><img src="./img/central.png" alt="集中式版本控制系统"></p>
<ul>
<li>工具：<code>SVN</code>、CVS、Subversion、Perforce 等</li>
<li>特点：使用单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端
连到这台服务器，取出最新的文件或者提交更新</li>
<li>缺点：<ul>
<li>1：需要一台中央服务器</li>
<li>2：中央服务器的单点故障，故障期间无法协同工作</li>
<li>3：中心数据库所在的磁盘发生损坏，如果没有备份，会造成数据丢失</li>
<li>4：依赖于网络</li>
</ul>
</li>
</ul>
<h3 id="-">分布式版本控制系统</h3>
<p><img src="./img/distributed.png" alt="分布式版本控制系统"></p>
<ul>
<li>工具：<strong>Git</strong>、Mercurial、Bazaar 以及 Darcs 等</li>
<li>特点：每个客户端都有一份代码仓库完整地镜像（副本）</li>
</ul>
<h2 id="git-">Git简介</h2>
<ul>
<li><a href="https://git-scm.com">官网</a></li>
<li><a href="https://git-scm.com/book/zh/v2">文档</a></li>
</ul>
<h3 id="-git">什么是Git</h3>
<pre><code>Git是一款免费、开源的分布式 `版本控制软件` （VCS - Version Control System）
由 Linus Torvalds（林纳斯·托瓦兹）于2005年发布
最初目的是为更好地管理 Linux内核 开发而设计

Git使用方式：1 命令 、2 图形化界面（GUI）
</code></pre><h3 id="git-">Git的优势</h3>
<ul>
<li>1 速度快，非常快，及其快</li>
<li>2 简单（不同命令，完成不同功能）</li>
<li>3 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li>
<li>4 完全分布式，不需要中央服务器就可以运行</li>
<li>5 有效、高速、高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li>
<li>6 Git中绝大多数的任务都是在本地完成的</li>
<li>7 使得源代码的发布和交流极其方便</li>
</ul>
<h2 id="git-">Git的基本使用</h2>
<ul>
<li><p>安装：<a href="https://git-scm.com/downloads">Git 下载地址</a></p>
</li>
<li><p>查看版本：<code>git --version</code></p>
</li>
<li>查看帮助：<code>git --help</code></li>
<li>查看命令帮助：<code>git add -h</code></li>
<li>查看详细帮助：<code>git add --help</code></li>
</ul>
<h3 id="-">基础配置</h3>
<ul>
<li>作用：每次 Git 提交时都会引用这两条信息，记录是谁提交了更新</li>
<li>配置用户名：   <code>git config --global user.name &quot;用户名&quot;</code></li>
<li>配置邮箱：     <code>git config --global user.email &quot;邮箱地址&quot;</code></li>
<li>查看配置信息： <code>git config --list</code></li>
<li><code>--global</code>全局配置的说明：<ul>
<li>添加<code>--global</code>参数后，对电脑中任何位置的git仓库都有效</li>
<li>没有添加<code>--global</code>参数，只对当前仓库有效</li>
</ul>
</li>
</ul>
<h3 id="-">使用流程</h3>
<ul>
<li>1 初始化仓库</li>
<li>2 暂存文件</li>
<li>3 提交</li>
</ul>
<h3 id="-">初始化仓库</h3>
<ul>
<li>命令：<code>git init</code></li>
<li>作用：使用Git管理项目的初始化操作，会创建一个名为<code>.git</code>的隐藏目录</li>
<li><code>.git</code>目录（不要修改这个文件）</li>
</ul>
<pre><code>这个目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是Git 仓库的骨干。

它是 Git 用来保存元数据和对象数据库的地方。
该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。
</code></pre><h3 id="-">暂存文件</h3>
<ul>
<li>作用：将文件由 工作区 添加到 暂存区（Index），暂存文件</li>
<li>命令：<code>git add 文件路径</code><ul>
<li>例如： <code>git add ./README.md</code></li>
</ul>
</li>
<li><code>git add --all</code> 或者 <code>git add -A</code>（简写） 添加所有文件</li>
<li><code>git add a.txt b.txt</code> 同时添加两个文件</li>
<li><code>git add *.js</code> 添加当前目录下的所有js文件</li>
</ul>
<h3 id="-">提交更新</h3>
<ul>
<li>作用：将文件由 暂存区 添加到 仓库（HEAD）</li>
<li><code>git commit -m &#39;提交说明&#39;</code></li>
<li>跳过暂存区直接提交：<code>git commit -a -m 提交说明</code><ul>
<li>注意：-a 和 -m 不能颠倒的！！！</li>
</ul>
</li>
<li>重新提交：<code>git commit --amend</code><ul>
<li>1 提交信息输入错误</li>
<li>2 遗漏某些需要提交的文件</li>
</ul>
</li>
</ul>
<h3 id="-">查看文件状态</h3>
<ul>
<li>命令：<code>git status</code></li>
<li>命令：<code>git stauts -s</code> 简化日志输出格式<ul>
<li><code>??</code> 表示未追踪的文件</li>
<li><code>A</code>  表示已经添加暂存区的文件</li>
<li><code>M</code>  表示修改过的文件<ul>
<li>右边的M: 表示该文件被修改了但是还没放入暂存区</li>
<li>左边的M: 表示该文件被修改了并放入了暂存区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="git-">Git三种状态和分区</h2>
<p><img src="./img/areas.png" alt="git状态"></p>
<blockquote>
<p>Woriking Directory: 工作区
Staging area: 暂存区
.git directory(repository): Git仓库</p>
</blockquote>
<h3 id="-">三个存储分区的说明</h3>
<pre><code>1 工作区：开发者的工作目录
2 暂存区：临时存放工作目录中变更的文件
3 仓库  ：存储提交之后的文件目录

Git仓库目录：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。

工作目录：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。

暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作 index，不过一般说法还是叫暂存区域
</code></pre><h3 id="-">文件的三种状态</h3>
<pre><code>已修改（modified）=&gt; 已暂存（staged）=&gt; 已提交（committed）

已修改：表示修改了某个文件，但还没有提交保存
已暂存：表示把已修改的文件放在下次提交时要保存的清单中
已提交：表示该文件已经被安全地保存在本地git仓库中了
</code></pre><h3 id="git-">Git工作流程</h3>
<p><img src="./img/lifecycle.png" alt="文件状态变化周期"></p>
<ul>
<li><code>Untracked</code>：文件还没有被git管理</li>
<li><code>Staged</code>：文件已添加到暂存区</li>
<li><code>Unmodified</code>：文件提交到仓库区</li>
<li><code>Modified</code>：仓库区的文件再次被修改</li>
</ul>
<pre><code>1 在工作目录中修改某些文件。
2 对修改后的文件进行快照，然后保存到暂存区域。
3 提交更新，将保存在暂存区域的文件快照永久转储到.git目录中。
</code></pre><h3 id="-">查看提交日志</h3>
<ul>
<li>命令：<code>git log</code> 查看详细的提交信息</li>
<li>命令：<code>git log --oneline</code> 简洁的日志信息</li>
<li>命令：<code>git reflog</code> 查看所有提交变更操作</li>
</ul>
<h3 id="-">版本回退</h3>
<ul>
<li>作用：恢复到已经提交的某一个版本中</li>
<li><p>命令：<code>git reset --hard [版本号]</code></p>
<ul>
<li>作用：回退到指定的版本号</li>
</ul>
</li>
<li><p>其他方式：<code>git reset --hard head~1</code></p>
<ul>
<li>~1 表示回到上一次提交</li>
<li>~2 表示上上一次提交</li>
<li>~0 表示当前提交</li>
</ul>
</li>
</ul>
<h3 id="-">忽略文件</h3>
<ul>
<li>作用：忽略一些不需要被git管理的文件</li>
<li>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。!!!</li>
<li><a href="https://github.com/github/gitignore">git忽略文件-详细参考</a></li>
</ul>
<pre><code>1 在与 .git 隐藏目录同级的目录中创建 `.gitignore` 文件
2 打开 .gitignore 文件，加入忽略文件，例如：/test.html
3 路径是相对于当前 .gitignore文件 的路径

路径写法：
/css/a.css
/css/*.css
/a.html

#忽略 build/ 目录下的所有文件
build/

# 忽略后缀名为 .a 的所有文件
*.a

# !表示取反，继续追踪名为：lib.a 的文件
!lib.a

# 只忽略根目录下的 TODO文件夹，不包含 subdir/TODO
/TODO

# 忽略doc/notes.txt, 但 doc/server/arch.txt 不会忽略
doc/*.txt

# 忽略 doc/ 文件夹下所有后缀名为 .pdf 的文件
doc/**/*.pdf
</code></pre><h3 id="-">忽略文件的说明</h3>
<ul>
<li>1 使用 <code>#</code> 表示注释，例如：<code># 这是注释内容</code></li>
<li>2 使用 <code>*</code> 表示通配符，匹配所有文件，例如：<code>/css/*.css</code></li>
</ul>
<h2 id="-">分支</h2>
<blockquote>
<p>几乎所有的版本控制系统都以某种形式支持分支。  使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
</blockquote>
<ul>
<li>场景：正在为了完成任务而撸码中，突然接到电话：有一个严重的bug需要修改，此时，我们应该怎么做？</li>
</ul>
<h3 id="-">分支操作</h3>
<ul>
<li><p>查看分支：<code>git branch</code>，当前分支会标有一个<code>*</code></p>
</li>
<li><p>创建分支：<code>git branch [分支名称]</code></p>
<ul>
<li>分支中的代码，与创建那一刻主分支中的内容完全相同</li>
</ul>
</li>
<li><p>切换分支：<code>git checkout [分支名称]</code></p>
<ul>
<li>切换分支之前, 必须在当前分支中完成所有的提交了</li>
</ul>
</li>
<li><p>(简写)创建并切换分支：<code>git checkout -b [分支名称]</code></p>
</li>
<li><p>合并分支：<code>git merge [分支名称]</code>，即：将其他分支合并到当前分支</p>
</li>
<li><p>删除分支：<code>git branch -d [分支名称]</code></p>
</li>
</ul>
<h3 id="-">合并分支冲突</h3>
<ul>
<li>注意：合并分支时出现冲突只能手动处理文件，然后，再次提交</li>
</ul>
<pre><code>如果在一个从分支中做了修改，然后，在主分支中也做了修改。
此时，将这个从分支合并到主分支的时候，就会出现合并冲突的问题！


在两个分支中同时修改了一个文件中的内容，此时，就会造成合并分支冲突
，如果发生了合并冲突，需要我们手动解决！

1 决定保留哪个分支中的内容
2 重新提交


操作：将 hotfix 分支，合并到cart分支中

HEAD：表示当前分支
hotfix： 表示被合并分支

 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
        &lt;span&gt;第三次修改的内容&lt;/span&gt;

        &lt;cart&gt;这是在 cart 分支中提交的内容&lt;/cart&gt;
 =======
        &lt;span&gt;第三次修改的内容 --- hotfix 修改bug&lt;/span&gt;
 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hotfix
</code></pre><h3 id="-">分支的说明</h3>
<ul>
<li>1 公司开发的项目都是由多个分支组成：主分支 + dev分支</li>
<li>2 项目经理新建项目仓库，所有的程序员都从这个仓库中获取代码，完成开发任务</li>
<li>3 项目经理：搭建设计仓库，创建master分支，以及dev分支（以及 debug分支等）</li>
<li>4 所有的程序员在 dev分支 上进行开发，并且还有自己维护的分支</li>
<li>5 程序员在分支上完成开发任务后，会提交合并请求</li>
<li>6 项目经理安排测试，如果没有问题了，最后才会与 master 分支合并</li>
</ul>
<h2 id="github-">github 介绍</h2>
<ul>
<li><a href="https://github.com/">github 官网</a></li>
<li><a href="https://git.oschina.net/">开源中国-Git</a></li>
</ul>
<pre><code>在 GitHub 上免费托管的 Git 仓库，任何人都可以看到喔（但只有你自己才能改）。
所以，不要把敏感信息放进去。
</code></pre><h3 id="github-git">github与git</h3>
<ul>
<li>git 是一个版本控制工具</li>
<li>github就是一个网站(软件项目平台)，这个网站提供了 git 服务器的功能，我们可以使用git命令来操作托管的项目</li>
</ul>
<h2 id="-">远程仓库操作</h2>
<h3 id="-https-">将代码提交到远程仓库（HTTPS）</h3>
<ul>
<li>1 在本地创建仓库<ul>
<li><code>git init</code></li>
<li><code>git config</code></li>
</ul>
</li>
<li>2 新建 README.md 文件，并输入任意内容</li>
<li>3 将 README.md 提交到本地<ul>
<li><code>git add</code></li>
<li><code>git commit</code></li>
</ul>
</li>
<li>4 在github中新建仓库，并拿到仓库地址</li>
<li>5 使用命令 <code>git push [仓库地址] master</code> 提交内容到github的默认分支</li>
<li>6 刷新github仓库页面，在线修改 README.md 文件，并提交</li>
<li>7 使用命令 <code>git pull [仓库地址] master</code> 获取仓库中的最新内容</li>
</ul>
<h3 id="-">获取远程仓库内容</h3>
<ul>
<li><p>命令：<code>git pull [仓库地址] [分支名称]</code> 获取远程仓库最新内容</p>
</li>
<li><p>命令：<code>git clone [仓库地址] [自定义本地仓库名]</code> 将整个仓库克隆到本地</p>
<ul>
<li>实例：<code>git clone git://github.com/jquery/jquery.git myJQ</code></li>
</ul>
</li>
<li>当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来</li>
<li><a href="http://blog.csdn.net/yuanchao99/article/details/39118439">git clone分支说明</a></li>
</ul>
<h3 id="-">简化操作</h3>
<ul>
<li>1 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code><ul>
<li>shortname 可以是任意的名称，比如：git666</li>
<li>作用：使用shortname代替 url ，方便操作</li>
<li>shortname就相当于js的变量，[url]就相当于变量的值</li>
<li>设置以后，提交操作变为：<code>git push origin master</code></li>
<li>重命名：<code>git remote rename origin git666</code></li>
<li>删除：  <code>git remote rm origin</code></li>
</ul>
</li>
<li>2 <code>git push -u origin master</code><ul>
<li>作用：<code>-u</code>参数将origin与master连在一起</li>
</ul>
</li>
<li>3 使用简化命令 <code>git push origin</code> 就代替原来：&quot;git push [仓库地址] master&quot;</li>
</ul>
<h3 id="ssh-">SSH介绍</h3>
<ul>
<li>非对称加密、公钥和私钥</li>
</ul>
<pre><code>GitHub 需要识别出你推送的提交确实是你推送的，而不是别人冒充的，
而 Git 支持 SSH 协议，所以，GitHub 只要知道了你的公钥，
就可以确认只有你自己才能推送，从而省去每次输入密码的操作。

可以同时设置多个SSH key，比如：你可以在公司电脑提交需要一个key，
回家后自己的电脑提交也需要一个key

ssh是一种安全的传输模式
github要求推送代码的用户是合法的，所以每次推送时候都要输入账号密码，
用以验证你是否为合法用户，为了省去每次都要输入密码的步骤，采用shh公钥，密钥
也就是你说的sshkey来验证你是否为合法用户
在你的电脑生成了一个唯一的ssh公钥和私钥，公钥放到github上面，当你推送的时候，git就会
匹配你的私钥是否跟github上面的公钥是配对的，正确就认为你是合法的，允许推送。

sshkey可以理解为是你的身份标识，放在github上面表明你是这个项目的一个开发人员，但是别
人是可以截获的，你本机的私钥别人就无法截获，sshkey就可以保证每次传输都是安全的。
</code></pre><h3 id="-ssh-">将代码提交到远程仓库（SSH）</h3>
<ul>
<li>1 创建SSH Key：<code>ssh-keygen -t rsa</code></li>
<li>2 在文件路径 <code>C:\用户\当前用户名\</code> 找到 <code>.ssh</code> 文件夹</li>
<li>3 文件夹中有两个文件：<ul>
<li>私钥：<code>id_rsa</code></li>
<li>公钥：<code>id_rsa.pub</code></li>
</ul>
</li>
<li>4 在 <code>github -&gt; settings -&gt; SSH and GPG keys</code>页面中，新创建SSH key</li>
<li>5 粘贴 公钥 <code>id_rsa.pub</code> 内容到对应文本框中</li>
<li>5 在github中新建仓库或者使用现在仓库，拿到<code>git@github.com:用户名/仓库名.git</code></li>
<li>6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了</li>
</ul>
<h3 id="-">最佳实践</h3>
<ul>
<li><p>先获取再提交，即：先<code>pull</code>再<code>push</code></p>
</li>
<li><p>获取跟新的其他方式：<code>fetch</code> </p>
</li>
<li><a href="http://blog.csdn.net/u012150179/article/details/17172211">fetch的使用方式</a></li>
<li><a href="http://ruby-china.org/topics/4768">pull和fetch的区别</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">git远程操作</a></li>
</ul>
<pre><code class="lang-bash"># 从远程的origin仓库的master分支下载到本地并新建一个分支temp
git fetch origin master:temp
# 合并 temp 分支
git merge temp
# 删除 temp 分支
git branch -d temp
</code></pre>
<h2 id="github-">github搭建博客</h2>
<ul>
<li>github 提供了 静态服务器 的功能<ul>
<li>不需要服务器解析，浏览器直接能处理的文件（例如：js/css/html等）</li>
<li>动态页面：.jsp / .php / .asp / .aspx，或者html中包含php等代码都是动态页面</li>
</ul>
</li>
<li>使用github服务器的 <code>gh-pages</code> 分支</li>
</ul>
<pre><code>1 在本地工作目录使用git初始化 `git init`
2 创建自己的博客项目
3 将创建好的博客添加到暂存区 `git add [文件路径]`
4 本地提交： `git commit -m &quot;第一个博客&quot;`
5 创建分支：`git branch gh-pages` 分支名称固定！
6 切换分支：`git checkout gh-pages`
7 提交到github：`git push [github仓库地址] gh-pages`
8 查看github中对应的仓库中，是不是提交到了 &quot;gh-pages&quot; 分支
9 访问：&lt;github用户名&gt;.github.io/&lt;仓库名&gt;/&lt;文件名&gt;

10 默认会访问 index.html
</code></pre><h2 id="git-gui-">Git软件（GUI 图形化界面）</h2>
<ul>
<li>SourceTree / TortoiseGit</li>
<li><a href="http://backlogtool.com/git-guide/cn/">TortoiseGit使用教程</a></li>
</ul>
<h2 id="git-">Git -其他操作</h2>
<h3 id="-">文件对比</h3>
<ul>
<li>命令：<code>git diff</code>：将工作区与暂存区或者仓库对比</li>
<li><p>说明：如果暂存区没有文件，就会将工作区代码与上一次提交对比</p>
<ul>
<li>1 工作区 与 暂存区对比</li>
<li>2 工作区 与 仓库  对比</li>
</ul>
</li>
<li><p>命令：<code>git diff --staged</code>：将当前暂存区与仓库对比</p>
</li>
<li>命令：<code>git diff [版本号1] [版本号2] [对比的文件路径]</code><ul>
<li>对比仓库区两次提交的差异</li>
</ul>
</li>
</ul>
<h3 id="-">撤销和删除</h3>
<ul>
<li><code>git reset HEAD 文件名</code> 从暂存区撤销（结果：变为未 add 状态）</li>
<li><p><code>git checkout -- test.txt</code> 撤销文件变化</p>
<ul>
<li>一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>
</li>
<li><p><code>git rm [文件名称]</code>：从工作目录和暂存区中删除文件（物理删除）</p>
</li>
<li><code>git rm --cached [文件名称]</code>：从仓库或暂存区删除文件</li>
</ul>
<h3 id="-git-">.git目录结构介绍</h3>
<pre><code>hooks/：      包含客户端或服务端的钩子脚本（hook scripts）
info/：       包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在.gitignore文件中的忽略模式（ignored patterns）

objects/：    存储所有数据内容
refs/：       存储指向数据（分支）的提交对象的指针

config：      存放项目特有的配置选项
description： 文件仅供 GitWeb 程序使用，我们无需关心
HEAD：        文件保存暂存区信息，一般指向refs下的某文件
</code></pre><hr>
<h2 id="-">裸仓库</h2>
<p>一个远程仓库通常只是一个裸仓库（bare repository）— 即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁碟检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你专案目录内的 .git 子目录内容，不包含其他资料。</p>
<ul>
<li>命令：<code>git init --bare</code></li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>